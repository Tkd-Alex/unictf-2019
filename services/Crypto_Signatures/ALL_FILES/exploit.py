from pwn import *
import binascii
import csv
import hashlib
import sys
import random
import string

def s256(msg):
    # string hex sha256 of a string or hex string message
    try:
        return hashlib.sha256(binascii.unhexlify(msg)).hexdigest()
    except:
        return hashlib.sha256(msg.encode('utf-8')).hexdigest()

def kth_bit(n, k):
    # flag of the kth bit
    # e.g. k(8,1) == 0; k(8,3) == 1
    return 1 if n & (1 << (k)) else 0


def group_by_n(s, n=2):
    # takes a list or tuple and chunks it up into pairs or other n
    # e.g. (1,2,3,4,5,6) -> ((1,2),(3,4),(5,6))
    return [s[i:i + n] for i in range(0, len(s), n)]


def bit_stream_from_msg(msg):
    # given a hex string msg, generate a stream of 1 and 0
    # e.g. 'e8' -> (0,0,0,1,0,1,1,1)
    newmsg = int(msg, 16)
    for i in range(4 * len(msg))[::-1]:
        yield kth_bit(newmsg, i)

def make_top_hash_from_leaves(tree):
    # combine an ordered list key pairs to a top level public key.
    if len(tree) < 2:
        return tree[0]
    else:
        return make_top_hash_from_leaves(
            [s256(a + b) for a, b in group_by_n(tree)]
        )

def make_top_hash_from_others(initial, others):
    # traverse asymmetic segments of public key signature to get public key
    top_hash = initial
    #print(others)
    for rank, other in others:
        if int(rank): #rank == 1
            top_hash = s256(other + top_hash)
        else: #rank != 1 -> 0
            top_hash = s256(top_hash + other)
    return top_hash


def randomString(stringLength=64):
    """Generate a random string of fixed length """
    letters = string.ascii_letters
    return ''.join(random.choice(letters) for i in range(stringLength))

def generate_msg(identity):
	sender = identity
	sent = 'sent'
	money = random.uniform(0, 500)
	to = 'to'
	zuccoins = 'zuccoins'
	receiver = randomString()
	return (sender + ' ' + sent + ' ' + str(money) + ' ' + zuccoins + ' ' + to + ' ' + receiver)

def generate_couple():
	xr = randomString()
	yr = randomString()
	x = s256(xr)
	y = s256(yr)
	b = [xr, y]
	a = [x, yr]
	return (a, b)

def generate_other():
	bit = 0
	x = randomString()
	return [bit, x]

def generate_identity():
	signature = []
	for x in range(256):
		signature.append(generate_couple())
	others = []
	for x in range(5):
		others.append(generate_other())
	aux = []
	for sig in signature:
		aux.append(sig[0])
	pub_key_gen = []
	for x in aux:
		pub_key_gen.append(x[0])
		pub_key_gen.append(s256(x[1]))
	top_key = make_top_hash_from_leaves(pub_key_gen)
	identity = make_top_hash_from_others(top_key, others)
	return (identity, signature, others)

def generate_signature(identity, signature, others):
	msg = generate_msg(identity)
	h_msg = s256(msg)
	final_sign = identity + ',' + msg
	for bit, sign in zip(bit_stream_from_msg(h_msg), signature):
		if bit == 1:
			final_sign += ',' + ",".join(sign[0])
		else:
			final_sign += ',' + ",".join(sign[1])
	for x in others:
		final_sign += ',' + str(x[0]) + ','
		final_sign += x[1] 
	return final_sign

ip = "192.168.10.20"
port = 47835
conn = remote(ip, port)

identity, signature, others = generate_identity()
sign = generate_signature(identity, signature, others)

print(conn.readuntil('form: '))
conn.send(sign+'\n')
res = conn.readall()
print(res)
res = res.splitlines()
flag = filter(lambda x: 'unictf{' in x, res)
if flag:
	print("Founded Flag: " + flag[0])
else:
	print("Flag not Found")


